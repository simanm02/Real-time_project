================================================================
RepopackPy Output File
================================================================

This file was generated by RepopackPy on: 2025-03-25T18:04:17.340044

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and RepopackPy's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

For more information about RepopackPy, visit: https://github.com/abinthomasonline/repopack-py

================================================================
Repository Structure
================================================================
.github\workflows\audit.yml
.github\workflows\clippy.yml
.github\workflows\lint.yml
.github\workflows\rust.yml
.gitmodules
Cargo.toml
README.md
src\elevio\cost.rs
src\elevio\elev.rs
src\elevio\fault_handler.rs
src\elevio\poll.rs
src\lib.rs
src\main.rs
src\network\p2p_connect.rs

================================================================
Repository Files
================================================================

================
File: .gitmodules
================
[submodule "Simulator-v2"]
	path = Simulator-v2
	url = https://github.com/TTK4145/Simulator-v2.git

================
File: Cargo.toml
================
[package]
name = "driver-rust"
version = "0.1.0"
authors = ["Anders Petersen <klasbo@gmail.com>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
#driver-rust = {git = "https://github.com/TTK4145/driver-rust", tag = "v0.1.0" }
crossbeam-channel = "0.5"

[lib]
name = "driver_rust"
path = "src/lib.rs"

[[bin]]
name = "driver-rust"
path = "src/main.rs"

================
File: README.md
================
# Elevator Control System Rust Docs

## Project Overview
This code implements a control system for one signel elevator operating across four floors. The system is built in Rust and communicates with the elevator hardware through a TCP connection.

Call queues and prioritization are handled according to the spec. The obstruction lever is implemented in such a way that it only halts the elevator if the door is open, or, if it's currently moving towards a floor, it waits and halts the elevator at the moment when the door opens. The stop button stops the elevator immediately no matter what, and clears all queues.

## System structure
The system spawns individual crossbeam channels for communication between threads that can't be accessed by any other process. These are threads that send events to the main control loop, and each sensor type has its own dedicated polling thread, including call buttons, floor sensors, stop button and obstruction sensor.

The elevator hardware then uses TCP in order for the elevator hardware to communicate with the polling threads, which has channels to the main control loop.

Elevator calls are stored in a vector within the Elevator struct, with cabin calls given priority over hall calls.

## Module overview

### src/lib.rs
This is the "library" file that connects the supporting files in the "elevio" folder, which is used in main.rs, and makes it clear which files are implemented and doing what.

### src/elevio/elev.rs
This file contains functions that manipulate the various elevator values and states such as lights, stop button true/false, obstruction true/false, motor direction, etc. All of this is implemented in the core `Elevator` struct that makes up all of its parameters.

### src/elevio/poll.rs
This file implements the polling threads containing the data used by main.rs to determine system behavior. The function `call_buttons` continuously checks for call button presses, `floor_sensor` continuously checks for which floor the elevator is at, and `stop_button` and `obstruction` also monitor whether or not someone has activated the stop button or obstruction lever respectively. 

### src/main.rs
This file handles the main logic of the system, including initialization, call queueing, deciding motor direction, looping through the polling of input data, etc. This behaviour is determined by polled inputs by the threads in poll.rs, which is passed on to main.rs where the system logic is handled by five main modules:
- `direction_call`: This function decides which direction the elevator should move in when a call is received.
- `add_call_request`: This creates a vector `callbutton`, containing data on floor and whether it is an UP, DOWN or CAB call. This is then pushed to the call_buttons queue.
- `start_elevator`: This is initialized once a call is received, and uses `direction_call` to move in the right direction.
- `serve_call`: This function contains the logic that decides which call it should move on to next once a call has been served. This can depend on where in the queue the call is, and which direction the elevator is originally intending to go next.
- `main`: This is the main function that combines all the functions above and sets variables on startup. It enters into the `loop`, which uses `cbc::select!`  to deteremine which functions to call and variables to set, based on exactly which thread it is receiving data from using `recv()`.

## Call Handling algorithm

When a call button is pressed:
1. The call is added to the queue if not already present
2. If the elevator is idle, it starts moving toward the call
3. When reaching a floor:
   - If the floor has a call matching current direction or cabin call, serve it
   - Open door for 3 seconds
   - Determine next direction based on remaining calls

Cabin calls take priority over hall calls to optimize efficiency.

## How to run and test
1. Have rust installed on the computer
2. Open a terminal and navigate to the cargo folder (the one containing 'Cargo.toml')
3. Build and run by typing 'cargo run'

## Future Improvements
- Implement multi-elevator support with distributed call allocation
- Add network resilience for handling disconnections
- Optimize call serving algorithm for better efficiency

================
File: .github\workflows\audit.yml
================
name: Security audit
on:
  push:
    paths: 
      - '**/Cargo.toml'
      - '**/Cargo.lock'
jobs:
  security_audit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v1
      - uses: actions-rs/audit-check@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

================
File: .github\workflows\clippy.yml
================
name: Clippy

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

env:
  CARGO_TERM_COLOR: always

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Setup
      run: rustup component add clippy rustfmt
    - name: Build
      run: cargo clippy -- -D warnings
    - name: Run tests
      run: cargo fmt -- --check

================
File: .github\workflows\lint.yml
================
name: Lint Code Base

#
# Documentation:
# https://help.github.com/en/articles/workflow-syntax-for-github-actions
#

on:
  push:
    branches-ignore: [ master ]
    # Remove the line above to run when pushing to master
  pull_request:
    branches: [ master ]

jobs:
  build:
    name: Lint Code Base
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v2
        with:
          # Full git history is needed to get a proper list of changed files within `super-linter`
          fetch-depth: 0

      - name: Lint Code Base
        uses: github/super-linter@v3
        env:
          VALIDATE_ALL_CODEBASE: false
          DEFAULT_BRANCH: master
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VALIDATE_MARKDOWN: true

================
File: .github\workflows\rust.yml
================
name: Rust

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

env:
  CARGO_TERM_COLOR: always

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Build
      run: cargo build --verbose
    - name: Run tests
      run: cargo test --verbose

================
File: src\lib.rs
================
pub mod elevio {
    pub mod elev;
    pub mod poll;
    pub mod cost;
    pub mod fault_handler;
}
pub mod network {
    pub mod p2p_connect;
}

================
File: src\main.rs
================
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::SystemTime;
use std::env;
use std::time::Duration;
use std::collections::HashMap;
use std::io::{Read, Write};
use std::net::TcpListener;
use std::thread::sleep;
use crossbeam_channel as cbc;

use driver_rust::elevio;
use driver_rust::elevio::elev as e;
use driver_rust::elevio::elev::Elevator;
use driver_rust::network::p2p_connect;
use driver_rust::elevio::fault_handler;
use driver_rust::elevio::cost::{calculate_cost, ElevatorMessage};

// Structure to hold shared state for all elevators in the system
struct ElevatorSystem {
    // Local elevator state
    local_id: String,
    local_elevator: Arc<Mutex<Elevator>>,
    
    // Global system state
    hall_calls: Arc<Mutex<HashMap<(u8, u8), (String, u64)>>>, // (floor, direction) -> (aigned_to,ss timestamp)
    elevator_states: Arc<Mutex<HashMap<String, ElevatorState>>>,
    
    // Network communication
    network_manager: Arc<p2p_connect::NetworkManager>,
    peers: Arc<Mutex<Vec<String>>>, // Store peer addresses separately
}

// Structure to keep track of other elevator states
#[derive(Clone, Debug)]
struct ElevatorState {
    floor: u8,
    direction: u8,
    call_buttons: Vec<Vec<u8>>,
    last_seen: u64, // Timestamp of last update
}

fn direction_to_string(direction: u8) -> &'static str {
    match direction {
        e::DIRN_UP => "UP",
        e::DIRN_DOWN => "DOWN",
        e::DIRN_STOP => "STOP",
        _ => "UNKNOWN"
    }
}

impl ElevatorSystem {
    fn new(
        local_id: String, 
        elevator: Elevator, 
        network_manager: Arc<p2p_connect::NetworkManager>
    ) -> Self {
        let local_elevator = Arc::new(Mutex::new(elevator));
        
        ElevatorSystem {
            local_id,
            local_elevator,
            hall_calls: Arc::new(Mutex::new(HashMap::new())),
            elevator_states: Arc::new(Mutex::new(HashMap::new())),
            network_manager,
            peers: Arc::new(Mutex::new(Vec::new())),
        }
    }
    
    // Add a peer to our list
    fn add_peer(&self, addr: String) {
        let mut peers = self.peers.lock().unwrap();
        if !peers.contains(&addr) {
            peers.push(addr);
        }
    }
    
    
    // Broadcast a message to all peers
    fn broadcast_message(&self, message: &str) {
        let peers = self.peers.lock().unwrap();
        for addr in &*peers {
            p2p_connect::send(Arc::clone(&self.network_manager), addr, message);
        }
    }
    
    // Broadcast local elevator state to all peers
    fn broadcast_state(&self) {
        let elevator = self.local_elevator.lock().unwrap();
        
        let msg = ElevatorMessage::ElevatorState {
            id: self.local_id.clone(),
            floor: elevator.current_floor,
            direction: elevator.current_direction,
            call_buttons: elevator.call_buttons.clone(),
        };
        
        self.broadcast_message(&msg.to_string());
    }

    fn handle_hall_call_message(&self, floor: u8, direction: u8, timestamp: u64) {
        // Add to hall calls if newer than what we have
        let mut update_needed = false;
        {
            let mut hall_calls = self.hall_calls.lock().unwrap();
            
            if let Some((_, existing_timestamp)) = hall_calls.get(&(floor, direction)) {
                if timestamp > *existing_timestamp {
                    hall_calls.insert((floor, direction), (String::new(), timestamp));
                    update_needed = true;
                }
            } else {
                hall_calls.insert((floor, direction), (String::new(), timestamp));
                update_needed = true;
            }
        }
        
        if update_needed {
            // Turn on the hall call light
            {
                let elevator = self.local_elevator.lock().unwrap();
                elevator.call_button_light(floor, direction, true);
            }
            
            // Determine the best elevator for this call
            self.assign_hall_call(floor, direction, timestamp);
        }
    }


    
    // Process a new hall call
    fn process_hall_call(&self, floor: u8, direction: u8) {
        let timestamp = match SystemTime::now().duration_since(SystemTime::UNIX_EPOCH) {
            Ok(n) => n.as_secs(),
            Err(_) => 0,
        };
        
        // Broadcast the hall call to all peers
        let msg = ElevatorMessage::HallCall {
            floor,
            direction,
            timestamp,
        };
        
        // Store the hall call locally
        {
            let mut hall_calls = self.hall_calls.lock().unwrap();
            hall_calls.insert((floor, direction), (String::new(), timestamp)); // Initially unassigned
        }
        
        // Broadcast to all peers
        self.broadcast_message(&msg.to_string());
        
        // Determine the best elevator for this call
        self.assign_hall_call(floor, direction, timestamp);
    }

    fn handle_elevator_state_message(&self, id: String, floor: u8, direction: u8, call_buttons: Vec<Vec<u8>>) {
        // Update our knowledge of this elevator's state
        let mut elevator_states = self.elevator_states.lock().unwrap();
        
        let timestamp = match SystemTime::now().duration_since(SystemTime::UNIX_EPOCH) {
            Ok(n) => n.as_secs(),
            Err(_) => 0,
        };
        
        elevator_states.insert(id.clone(), ElevatorState {
            floor,
            direction,
            call_buttons,
            last_seen: timestamp,
        });
        
        // Re-evaluate hall call assignments
        drop(elevator_states); // Release the lock before calling assign_hall_call
        
        let hall_calls = self.hall_calls.lock().unwrap().clone();
        for ((call_floor, call_direction), (_, timestamp)) in hall_calls {
            self.assign_hall_call(call_floor, call_direction, timestamp);
        }
    }

    fn handle_completed_call_message(&self, floor: u8, direction: u8) {
        // Update hall call status
        {
            let mut hall_calls = self.hall_calls.lock().unwrap();
            hall_calls.remove(&(floor, direction));
        }
        
        // Turn off the hall call light
        {
            let elevator = self.local_elevator.lock().unwrap();
            elevator.call_button_light(floor, direction, false);
        }
    }


    
    // Assign a hall call to the best elevator
    // that properly handles ties in cost calculation

    

    fn assign_hall_call(&self, floor: u8, direction: u8, timestamp: u64) {
        // Check if call is already assigned
        {
            let hall_calls = self.hall_calls.lock().unwrap();
            if let Some((assigned_id, existing_ts)) = hall_calls.get(&(floor, direction)) {
                // If already assigned to someone, and no "newer" timestamp, do nothing
                if !assigned_id.is_empty() && *existing_ts == timestamp {
                    // Don't print anything - reduces console spam
                    return;
                }
            }
        }
        
        // Store (cost, id) pairs for all elevators
        let mut all_costs: Vec<(i32, String)> = Vec::new();
        
        // Calculate cost for local elevator
        {
            let elevator = self.local_elevator.lock().unwrap();
            let cost = calculate_cost(
                elevator.current_floor,
                elevator.current_direction,
                elevator.call_buttons.len(),
                floor,
                direction
            );
            all_costs.push((cost, self.local_id.clone()));
        }
        
        // Calculate costs for other elevators
        {
            let elevator_states = self.elevator_states.lock().unwrap();
            
            for (id, state) in elevator_states.iter() {
                // Calculate cost using state information directly
                let cost = calculate_cost(
                    state.floor,
                    state.direction,
                    state.call_buttons.len(),
                    floor,
                    direction
                );
                all_costs.push((cost, id.clone()));
            }
        }
        
        // Sort by cost (ascending) and then by id (ascending) for consistent tie-breaking
        all_costs.sort_by(|a, b| {
            match a.0.cmp(&b.0) {
                std::cmp::Ordering::Equal => a.1.cmp(&b.1),
                other => other,
            }
        });
        
        // The best elevator is the first in the sorted list
        if let Some((_, best_id)) = all_costs.first() {
            let best_id = best_id.clone();
            
            // Only print if this elevator is the one assigned to handle the call
            if best_id == self.local_id {
                println!("Hall call (floor {}, dir {}) assigned to this elevator", 
                    floor, direction_to_string(direction));
            }
                
            // Update hall call assignment
            {
                let mut hall_calls = self.hall_calls.lock().unwrap();
                hall_calls.insert((floor, direction), (best_id.clone(), timestamp));
            }
            
            // If we are the best elevator, add the call to our queue
            if best_id == self.local_id {
                let mut elevator = self.local_elevator.lock().unwrap();
                
                // Set the call button light
                elevator.call_button_light(floor, direction, true);
                
                // Add to our queue if not already there
                let callbutton = vec![floor, direction];
                if !elevator.call_buttons.iter().any(|x| x == &callbutton) {
                    elevator.call_buttons.push(callbutton);
                }
                
                // Start elevator if needed
                start_elevator(&mut elevator, floor, direction);
            }
        }
    }

    
    
    // Handle a completed call
    fn complete_call(&self, floor: u8, direction: u8) {
        // Remove from hall calls
        {
            let mut hall_calls = self.hall_calls.lock().unwrap();
            hall_calls.remove(&(floor, direction));
        }
        
        // Broadcast completion to all peers
        let msg = ElevatorMessage::CompletedCall {
            floor,
            direction,
        };
        
        self.broadcast_message(&msg.to_string());
    }
    
    /// Process a message received from another elevator
    fn process_message(&self, message: ElevatorMessage, from_addr: Option<String>) {
        // If we got this message from a specific address, make sure it's in our peer list
        if let Some(addr) = from_addr {
            self.add_peer(addr);
        }
        
        match message {
            ElevatorMessage::HallCall { floor, direction, timestamp } => {
                self.handle_hall_call_message(floor, direction, timestamp);
            },
            ElevatorMessage::ElevatorState { id, floor, direction, call_buttons } => {
                self.handle_elevator_state_message(id, floor, direction, call_buttons);
            },
            ElevatorMessage::CompletedCall { floor, direction } => {
                self.handle_completed_call_message(floor, direction);
            }
        }
    }
    
    // Check for and handle disconnected elevators
    fn check_disconnected_elevators(&self) {
        let current_time = match SystemTime::now().duration_since(SystemTime::UNIX_EPOCH) {
            Ok(n) => n.as_secs(),
            Err(_) => 0,
        };
        
        let mut disconnected_ids = Vec::new();
        
        // Identify disconnected elevators (those not seen in the last 10 seconds)
        {
            let elevator_states = self.elevator_states.lock().unwrap();
            for (id, state) in elevator_states.iter() {
                if current_time - state.last_seen > 10 {
                    disconnected_ids.push(id.clone());
                }
            }
        }
        
        // Remove disconnected elevators
        if !disconnected_ids.is_empty() {
            let mut elevator_states = self.elevator_states.lock().unwrap();
            for id in &disconnected_ids {
                elevator_states.remove(id);
                println!("Elevator {} disconnected", id);
            }
        }
        
        // Reassign calls from disconnected elevators
        if !disconnected_ids.is_empty() {
            let mut reassign_calls = Vec::new();
            
            {
                let hall_calls = self.hall_calls.lock().unwrap();
                
                for ((floor, direction), (assigned_to, timestamp)) in hall_calls.iter() {
                    if disconnected_ids.contains(assigned_to) {
                        reassign_calls.push((*floor, *direction, *timestamp));
                    }
                }
            }
            
            // Reassign each call
            for (floor, direction, timestamp) in reassign_calls {
                self.assign_hall_call(floor, direction, timestamp);
            }
        }
    }
}

// Function to start elevator movement based on its call queue
fn start_elevator(elevator: &mut Elevator, go_floor: u8,  mut dirn: u8) {
    if elevator.call_buttons.len() == 1 || (elevator.call_buttons.len() > 1 && elevator.current_direction == e::DIRN_STOP) {
        dirn = hall_call_start_dir(go_floor, elevator.current_floor, dirn);
        elevator.current_direction = dirn;
        elevator.motor_direction(dirn);
    }
}
fn decide_next_call(elevator: &mut Elevator) -> Option<&Vec<u8>> {
    if let Some(next_call) = elevator.call_buttons.iter().find(|call| {
        (elevator.current_direction == e::DIRN_UP && call[0] > elevator.current_floor) ||
            (elevator.current_direction == e::DIRN_DOWN && call[0] < elevator.current_floor)
    }) {
        Some(next_call)
    } else if let Some(next_call) = elevator.call_buttons.iter().find(|call| call[0] == elevator.current_floor ){
        // Handle case when no calls in the current direction
        Some(next_call)
    } else {
        elevator.call_buttons.first()
    }

}
fn hall_call_start_dir (go_floor: u8, floor: u8, mut dirn: u8) -> u8 {
    if floor < go_floor {
        dirn = e::DIRN_UP;
    } else if floor > go_floor {
        dirn = e::DIRN_DOWN;
    } else {
        dirn = e::DIRN_STOP;
    }
    println!("Direction: {:#?}", dirn);
    dirn
}

fn decide_direction_by_call(call: u8) -> u8 {
    if call == 0 {
        e::DIRN_UP
    } else if call == 1 {
        e::DIRN_DOWN
    } else {
        e::DIRN_STOP
    }
}
fn decide_call_by_direction(dirn: u8) -> u8 {
    if dirn == e::DIRN_UP {
        0
    } else if dirn == e::DIRN_DOWN {
        1
    } else {
        2
    }
}

fn is_more_request_in_dir(elevator:  Elevator) -> bool {
    elevator.call_buttons.iter().any(|call| {
        (elevator.current_direction == e::DIRN_UP && call[0] > elevator.current_floor) ||
            (elevator.current_direction == e::DIRN_DOWN && call[0] < elevator.current_floor)
    })
}

fn opposite_dir(dirn: u8) -> u8 {
    if dirn == e::DIRN_UP {
        e::DIRN_DOWN
    } else {
        e::DIRN_UP
    }
}

fn find_call_button_index(call_button: Vec<u8>,elevator: &mut Elevator) -> Option<usize> {
    elevator.call_buttons.iter().position(|call| call == &call_button)
}

/*
// Function to handle calls when the elevator reaches a certain floor
fn serve_call(elevator_system: &ElevatorSystem, floor: u8) {
    let mut elevator = elevator_system.local_elevator.lock().unwrap();
    
    // If no calls to serve, return
    if elevator.call_buttons.is_empty() {
        return;
    }

    // Check if there is a call for this floor
    
    if let Some(pos) = elevator.call_buttons.iter().position(|call| call[0] == floor &&
        (decide_direction_by_call(call[1]) == elevator.current_direction || call[1] == e::CAB)
        || !is_more_request_in_dir(elevator.clone())) {

        //find the serving call
        let mut serving_call = vec![3,3];
        if let Some(same_direction_pos) = elevator.call_buttons.iter().position(|call| call[0] == floor &&
            (decide_direction_by_call(call[1]) == elevator.current_direction)) {
            serving_call = elevator.call_buttons.get(same_direction_pos).unwrap().clone();
            elevator.call_button_light(floor,serving_call[1], false);
            elevator.call_buttons.remove(same_direction_pos);
        }
        else if let Some(opp_dir_pos) = elevator.call_buttons.iter().position(|call| !is_more_request_in_dir(elevator.clone())
            && call[0] == floor && decide_direction_by_call(call[1]) == opposite_dir(elevator.current_direction)) {
            serving_call = elevator.call_buttons.get(opp_dir_pos).unwrap().clone();
            elevator.call_button_light(floor,serving_call[1], false);
            elevator.call_buttons.remove(opp_dir_pos);
        }
        //find if there is a cab call too
        if let Some(cab_call_pos) = elevator.call_buttons.iter().position(|call| call[0] == floor && call[1] == e::CAB) {
            elevator.call_button_light(floor, e::CAB, false);
            elevator.call_buttons.remove(cab_call_pos);
        }

        // Stop the elevator
        elevator.motor_direction(e::DIRN_STOP);
        //elevator.current_direction = e::DIRN_STOP;

        let call_type = serving_call[1];
        
        // If this was a hall call, mark it as completed
        if call_type != e::CAB {
            // Need to drop the elevator lock before acquiring system locks
            let completed_direction = call_type;
            drop(elevator);
            elevator_system.complete_call(floor, completed_direction);
            elevator = elevator_system.local_elevator.lock().unwrap();
        }

        println!("Call for floor {} removed", floor);
        
        // Open door for 3 seconds
        elevator.door_light(true);
        std::thread::sleep(Duration::from_secs(3));

        // Handle pending calls and decide next direction ;
        if let Some(next_call) = decide_next_call(&mut *elevator) {

            let next_floor = next_call[0];
            let next_call_type = next_call[1];
            let mut new_dir = if next_floor > floor {
                e::DIRN_UP
            } else if next_floor < floor {
                e::DIRN_DOWN
            } else {
                let next_call_index = find_call_button_index(next_call.clone(), &mut *elevator).unwrap();
                // If hall call, mark as completed
                if next_call_type != e::CAB {
                    // Need to drop the elevator lock before acquiring system locks
                    drop(elevator);
                    elevator_system.complete_call(floor, next_call_type);
                    elevator = elevator_system.local_elevator.lock().unwrap();
                }
                elevator.call_button_light(floor, next_call_type, false);
                elevator.call_buttons.remove(next_call_index);
                e::DIRN_STOP

            };
            if let Some(next_call) = decide_next_call(&mut *elevator) {
                if new_dir == e::DIRN_STOP {
                    new_dir = hall_call_start_dir(next_call[0], floor, new_dir);
                }
            }
            if new_dir == opposite_dir(elevator.current_direction) {
                println!("Opposite direction");
                sleep(Duration::from_secs(3));
            }
            elevator.door_light(false);
            elevator.current_direction = new_dir;
            elevator.motor_direction(new_dir);
        }
        elevator.door_light(false);
    }
}
     */

     fn serve_call(elevator_system: &ElevatorSystem, floor: u8) {
        let mut elevator = elevator_system.local_elevator.lock().unwrap();
    
        // If no calls to serve, return.
        if elevator.call_buttons.is_empty() {
            return;
        }
    
        // Try to find a call with the same direction as the elevator's current direction.
        let serving_call_opt = if let Some(pos) = elevator.call_buttons.iter().position(|call| {
            call[0] == floor && (decide_direction_by_call(call[1]) == elevator.current_direction || call[1] == e::CAB)
        }) {
            // Remove and return this call.
            let call = elevator.call_buttons.remove(pos);
            elevator.call_button_light(floor, call[1], false);
            Some(call)
        } 
        // If none found, check if there is a call with the opposite direction and no pending request in current direction.
        else if !is_more_request_in_dir(elevator.clone()) {
            if let Some(pos) = elevator.call_buttons.iter().position(|call| {
                call[0] == floor && decide_direction_by_call(call[1]) == opposite_dir(elevator.current_direction)
            }) {
                let call = elevator.call_buttons.remove(pos);
                elevator.call_button_light(floor, call[1], false);
                Some(call)
            } else {
                None
            }
        } else {
            None
        };
    
        // If no valid serving call was found, return without further action.
        let serving_call = match serving_call_opt {
            Some(call) => call,
            None => return,
        };
    
        // For cab calls, also check and remove any extra cab call.
        if let Some(cab_call_pos) = elevator.call_buttons.iter().position(|call| call[0] == floor && call[1] == e::CAB) {
            elevator.call_button_light(floor, e::CAB, false);
            elevator.call_buttons.remove(cab_call_pos);
        }
    
        // Stop the elevator.
        elevator.motor_direction(e::DIRN_STOP);
        let call_type = serving_call[1];
    
        // If this was a hall call, mark it as completed.
        if call_type != e::CAB {
            let completed_direction = call_type;
            drop(elevator);
            elevator_system.complete_call(floor, completed_direction);
            elevator = elevator_system.local_elevator.lock().unwrap();
        }
    
        println!("Call for floor {} removed", floor);
    
        // Open door for 3 seconds.
        elevator.door_light(true);
        std::thread::sleep(Duration::from_secs(3));
    
        // Decide next call.
        if let Some(next_call) = decide_next_call(&mut *elevator) {
            let next_floor = next_call[0];
            let next_call_type = next_call[1];
            let mut new_dir = if next_floor > floor {
                e::DIRN_UP
            } else if next_floor < floor {
                e::DIRN_DOWN
            } else {
                let next_call_index = find_call_button_index(next_call.clone(), &mut *elevator).unwrap();
                if next_call_type != e::CAB {
                    drop(elevator);
                    elevator_system.complete_call(floor, next_call_type);
                    elevator = elevator_system.local_elevator.lock().unwrap();
                }
                elevator.call_button_light(floor, next_call_type, false);
                elevator.call_buttons.remove(next_call_index);
                e::DIRN_STOP
            };
            if let Some(next_call) = decide_next_call(&mut *elevator) {
                if new_dir == e::DIRN_STOP {
                    new_dir = hall_call_start_dir(next_call[0], floor, new_dir);
                }
            }
            if new_dir == opposite_dir(elevator.current_direction) {
                println!("Opposite direction");
                sleep(Duration::from_secs(3));
            }
            elevator.door_light(false);
            elevator.current_direction = new_dir;
            elevator.motor_direction(new_dir);
        }
        elevator.door_light(false);
    }
    
// Custom message listener thread
fn message_listener(elevator_system: Arc<ElevatorSystem>, port: u16, fault_monitor: Arc<Mutex<fault_handler::ElevatorHealthMonitor>>) {
    // Create a TCP listener for direct message passing
    let listener = TcpListener::bind(format!("0.0.0.0:{}", port)).expect("Could not bind to address");
    println!("Message listener started on port {}", port);
    
    // Create a channel for passing messages to the processor
    let (tx, rx) = cbc::unbounded::<(String, String)>(); // (message, from_addr)
    
    // Accept connections and handle messages
    thread::spawn(move || {
        for stream in listener.incoming() {
            match stream {
                Ok(mut stream) => {
                    let addr = match stream.peer_addr() {
                        Ok(a) => a.to_string(),
                        Err(_) => continue,
                    };
                    
                    let tx_clone = tx.clone();
                    
                    thread::spawn(move || {
                        let mut buffer = [0; 1024];
                        
                        loop {
                            match stream.read(&mut buffer) {
                                Ok(0) => break, // Connection closed
                                Ok(n) => {
                                    let message = String::from_utf8_lossy(&buffer[..n]).to_string();
                                    tx_clone.send((message, addr.clone())).unwrap_or(());
                                },
                                Err(_) => break,
                            }
                        }
                    });
                },
                Err(e) => eprintln!("Error accepting connection: {}", e),
            }
        }
    });
    
    // Process received messages
    let elevator_system_clone = Arc::clone(&elevator_system);
    thread::spawn(move || {
        loop {
            match rx.recv_timeout(Duration::from_millis(500)) {
                Ok((message, from_addr)) => {
                    if let Some(parsed_msg) = ElevatorMessage::from_string(&message) {

                        if let ElevatorMessage::ElevatorState { ref id, .. } = parsed_msg {
                            fault_monitor.lock().unwrap().record_heartbeat(id);
                        }
                        elevator_system_clone.process_message(parsed_msg, Some(from_addr));
                    }
                },
                Err(_) => {
                    // Timeout - check for disconnected elevators
                    elevator_system_clone.check_disconnected_elevators();
                    
                    // Broadcast our state periodically
                    elevator_system_clone.broadcast_state();
                }
            }
        }
    });
}

fn main() -> std::io::Result<()> {
    // Get command line arguments
    let args: Vec<String> = env::args().collect();
    
    // Parse elevator ID and port
    let elev_id = if args.len() > 1 { args[1].clone() } else { "1".to_string() };
    let elev_port = if args.len() > 2 { 
        args[2].parse::<u16>().unwrap_or(15657) 
    } else { 
        15657 
    };
    
    let elev_num_floors = 4;
    
    println!("Starting elevator {} on port {}", elev_id, elev_port);
    
    // Initialize the elevator
    let server_addr = format!("localhost:{}", elev_port);
    let mut elevator = e::Elevator::init(&server_addr, elev_num_floors)?;

    if let Some((saved_floor, saved_direction, saved_calls)) = fault_handler::load_elevator_state(&elev_id) {
        println!("Recovered persisted state for elevator {}", elev_id);
        elevator.current_floor = saved_floor;
        elevator.current_direction = saved_direction;
        elevator.call_buttons = saved_calls;
        elevator.floor_indicator(saved_floor);
    }
    
    // Initialize network
    let network_port = 7878 + elev_port - 15657; // Network ports start at 7878
    let network_manager = p2p_connect::start_peer_manager(network_port);
    
    // Initialize elevator system
    /*
    let elevator_system = Arc::new(ElevatorSystem::new(
        elev_id.clone(),
        elevator.clone(),
        Arc::clone(&network_manager)
    ));
    */
    
        // Initialize elevator system
    let elevator_system = Arc::new(ElevatorSystem::new(
        elev_id.clone(),
        elevator.clone(),
        Arc::clone(&network_manager)
    ));

    // *** Add this line to broadcast the current state ***
    elevator_system.broadcast_state();


    let fault_monitor = fault_handler::ElevatorHealthMonitor::new();
    fault_handler::start_health_monitoring(Arc::clone(&fault_monitor), Arc::clone(&elevator_system.hall_calls));
    
    // Start message listener
    let message_port = 8878 + elev_port - 15657; // Message ports start at 8878
    message_listener(Arc::clone(&elevator_system), message_port, Arc::clone(&fault_monitor));
    
    // Try to connect to other potential elevators
    for i in 0..3 {
        if i != (elev_port - 15657) as usize {
            let peer_message_port = 8878 + i;
            let peer_addr = format!("localhost:{}", peer_message_port);
            let elevator_system_clone = Arc::clone(&elevator_system);
    
            thread::spawn(move || {
                // Retry connecting a few times
                for _ in 0..5 {
                    // 1) Attempt connection using p2p_connectâ€™s function
                    p2p_connect::connect(
                        Arc::clone(&elevator_system_clone.network_manager), 
                        &peer_addr
                    );
    
                    // 2) Add the peer to our local ElevatorSystem list (so we know about it)
                    elevator_system_clone.add_peer(peer_addr.clone());
    
                    // 3) Optionally send initial elevator state directly to that peer
                    //    (If you still want to replicate the original handshake logic)
                    match std::net::TcpStream::connect(&peer_addr) {
                        Ok(mut stream) => {
                            let elevator = elevator_system_clone.local_elevator.lock().unwrap();
                            let msg = ElevatorMessage::ElevatorState {
                                id: elevator_system_clone.local_id.clone(),
                                floor: elevator.current_floor,
                                direction: elevator.current_direction,
                                call_buttons: elevator.call_buttons.clone(),
                            };
                            stream.write_all(msg.to_string().as_bytes()).unwrap_or(());
                        },
                        Err(e) => {
                            println!("Failed to connect directly to peer at {}: {}", &peer_addr, e);
                        }
                    }
    
                    // Sleep a bit and retry
                    thread::sleep(Duration::from_secs(1));
                }
            });
        }
    }

    
    // Set up polling
    let poll_period = Duration::from_millis(25);
    
    // Crossbeam for call buttons
    let (call_button_tx, call_button_rx) = cbc::unbounded::<elevio::poll::CallButton>();
    {
        let elevator_clone = elevator.clone();
        thread::spawn(move || elevio::poll::call_buttons(elevator_clone, call_button_tx, poll_period));
    }
    
    // Crossbeam for floor sensor
    let (floor_sensor_tx, floor_sensor_rx) = cbc::unbounded::<u8>();
    {
        let elevator_clone = elevator.clone();
        thread::spawn(move || elevio::poll::floor_sensor(elevator_clone, floor_sensor_tx, poll_period));
    }
    
    // Crossbeam for stop button
    let (stop_button_tx, stop_button_rx) = cbc::unbounded::<bool>();
    {
        let elevator_clone = elevator.clone();
        thread::spawn(move || elevio::poll::stop_button(elevator_clone, stop_button_tx, poll_period));
    }
    
    // Crossbeam for obstruction
    let (obstruction_tx, obstruction_rx) = cbc::unbounded::<bool>();
    {
        let elevator_clone = elevator.clone();
        thread::spawn(move || elevio::poll::obstruction(elevator_clone, obstruction_tx, poll_period));
    }
    
    // Initialize elevator position
    {
        let elevator = elevator_system.local_elevator.lock().unwrap();
        
        // If the elevator isn't on a specific floor, move down until it reaches one
        if elevator.floor_sensor().is_none() {
            elevator.motor_direction(e::DIRN_DOWN);
        }
        
        // Turn off all call button lights at startup
        for call_type in 0..3 {
            for floor in 0..elev_num_floors {
                elevator.call_button_light(floor, call_type, false);
            }
        }
    }
    
    // Move elevator to ground floor at startup
    let mut starting_floor = floor_sensor_rx.recv().unwrap();
    {
        let mut elevator = elevator_system.local_elevator.lock().unwrap();
        while starting_floor != 0 {
            elevator.motor_direction(e::DIRN_DOWN);
            starting_floor = floor_sensor_rx.recv().unwrap();
            elevator.floor_indicator(starting_floor);
        }
        elevator.motor_direction(e::DIRN_STOP);
        elevator.current_floor = 0;
        elevator.floor_indicator(0);
    }
    
    // Main elevator control loop
    loop {
        cbc::select! {
            // Handle call button presses
            recv(call_button_rx) -> button_type => {
                let call_button = button_type.unwrap();
                println!("Call button pressed: {:#?}", call_button);
                
                if call_button.call == e::CAB {
                    // Handle cab call locally
                    let mut elevator = elevator_system.local_elevator.lock().unwrap();
                    elevator.call_button_light(call_button.floor, call_button.call, true);
                    
                    // Add to local queue
                    let callbutton = vec![call_button.floor, call_button.call];
                    if !elevator.call_buttons.iter().any(|x| x == &callbutton) {
                        elevator.call_buttons.push(callbutton);
                    }
                    
                    // Start elevator if needed
                    start_elevator(&mut elevator, call_button.floor, 0);
                } else {
                    // Handle hall call through the elevator system
                    elevator_system.process_hall_call(call_button.floor, call_button.call);
                }
            },
            
            // Handle floor sensor
            recv(floor_sensor_rx) -> floor_sensor_data => {
                let floor = floor_sensor_data.unwrap();
                
                // Update current floor
                {
                    let mut elevator = elevator_system.local_elevator.lock().unwrap();
                    elevator.current_floor = floor;
                    elevator.floor_indicator(floor);
                    println!("Floor: {:#?}", floor);
                }
                
                // Check if we need to serve any calls at this floor
                serve_call(&elevator_system, floor);
                
                // Broadcast updated state
                elevator_system.broadcast_state();
            },
            
            // Handle stop button
            recv(stop_button_rx) -> stop_btn => {
                let stop = stop_btn.unwrap();
                println!("Stop button: {:?}", stop);
                
                if stop {
                    let mut elevator = elevator_system.local_elevator.lock().unwrap();
                    
                    // Immediately stop the elevator
                    elevator.motor_direction(e::DIRN_STOP);
                    elevator.current_direction = e::DIRN_STOP;
                    
                    // Turn off all call button lights
                    for f in 0..elev_num_floors {
                        for c in 0..3 {
                            elevator.call_button_light(f, c, false);
                        }
                    }
                    
                    // Clear pending call requests
                    elevator.call_buttons.clear();
                    
                    // Open the door
                    elevator.door_light(true);
                    std::thread::sleep(Duration::from_secs(3));
                    elevator.door_light(false);
                    
                    // Broadcast updated state
                    drop(elevator);
                    elevator_system.broadcast_state();
                }
            },
            
            // Handle obstruction
            recv(obstruction_rx) -> obstruction => {
                let mut obstr = obstruction.unwrap();
                let mut elevator = elevator_system.local_elevator.lock().unwrap();
                
                if !elevator.floor_sensor().is_none() && obstr {
                    println!("Obstruction: {:#?}", obstr);
                    
                    while obstr {
                        elevator.motor_direction(e::DIRN_STOP);
                        drop(elevator);
                        obstr = obstruction_rx.recv().unwrap();
                        elevator = elevator_system.local_elevator.lock().unwrap();
                    }
                } else {
                    obstr = false;
                    println!("Obstruction: {:#?}", obstr);
                }
            },
        }
    }
}

================
File: src\elevio\cost.rs
================
use crate::elevio::elev::{DIRN_UP, DIRN_DOWN, DIRN_STOP};

// Simple cost calculation for elevator assignment
pub fn calculate_cost(
    current_floor: u8, 
    current_direction: u8, 
    call_buttons_len: usize,
    call_floor: u8, 
    call_direction: u8
) -> i32 {
    let mut cost = 0;
    
    // Base cost is the distance
    let floor_distance = if current_floor > call_floor {
        (current_floor - call_floor) as i32
    } else {
        (call_floor - current_floor) as i32
    };
    
    cost += floor_distance * 10;
    
    // Add cost for each pending call
    cost += call_buttons_len as i32 * 5;
    
    // Bonus if elevator is idle
    if current_direction == DIRN_STOP {
        cost -= 10;
    }
    
    // Bonus if elevator is already moving in the right direction
    if (current_direction == DIRN_UP && call_floor > current_floor && call_direction == DIRN_UP) ||
       (current_direction == DIRN_DOWN && call_floor < current_floor && call_direction == DIRN_DOWN) {
        cost -= 20;
    }
    
    // Penalty if elevator would need to reverse direction
    if (current_direction == DIRN_UP && call_floor < current_floor) ||
       (current_direction == DIRN_DOWN && call_floor > current_floor) {
        cost += 30;
    }
    
    cost
}

/// Message types for elevator network communication
#[derive(Debug, Clone)]
pub enum ElevatorMessage {
    /// Message for a new hall call
    HallCall { 
        floor: u8, 
        direction: u8, 
        timestamp: u64 
    },
    
    /// Message containing an elevator's current state
    ElevatorState { 
        id: String, 
        floor: u8, 
        direction: u8, 
        call_buttons: Vec<Vec<u8>> 
    },
    
    /// Message indicating a call has been completed
    CompletedCall { 
        floor: u8, 
        direction: u8 
    },
}

impl ElevatorMessage {
    // Convert message to string for network transmission
    pub fn to_string(&self) -> String {
        match self {
            ElevatorMessage::HallCall { floor, direction, timestamp } => {
                format!("HALL|{}|{}|{}", floor, direction, timestamp)
            },
            ElevatorMessage::ElevatorState { id, floor, direction, call_buttons } => {
                // Format call buttons as a compact string
                let buttons_str = call_buttons.iter()
                    .map(|call| format!("{},{}", call[0], call[1]))
                    .collect::<Vec<String>>()
                    .join(";");
                
                format!("STATE|{}|{}|{}|{}", id, floor, direction, buttons_str)
            },
            ElevatorMessage::CompletedCall { floor, direction } => {
                format!("COMPLETED|{}|{}", floor, direction)
            },
        }
    }
    
    // Parse string back to message
    pub fn from_string(s: &str) -> Option<Self> {
        let parts: Vec<&str> = s.split('|').collect();
        
        if parts.is_empty() {
            return None;
        }
        
        match parts[0] {
            "HALL" => {
                if parts.len() < 4 {
                    return None;
                }
                
                let floor = parts[1].parse::<u8>().ok()?;
                let direction = parts[2].parse::<u8>().ok()?;
                let timestamp = parts[3].parse::<u64>().ok()?;
                
                Some(ElevatorMessage::HallCall { floor, direction, timestamp })
            },
            "STATE" => {
                if parts.len() < 5 {
                    return None;
                }
                
                let id = parts[1].to_string();
                let floor = parts[2].parse::<u8>().ok()?;
                let direction = parts[3].parse::<u8>().ok()?;
                
                // Parse call buttons
                let mut call_buttons = Vec::new();
                if !parts[4].is_empty() {
                    for button_str in parts[4].split(';') {
                        let button_parts: Vec<&str> = button_str.split(',').collect();
                        if button_parts.len() == 2 {
                            if let (Ok(f), Ok(d)) = (button_parts[0].parse::<u8>(), button_parts[1].parse::<u8>()) {
                                call_buttons.push(vec![f, d]);
                            }
                        }
                    }
                }
                
                Some(ElevatorMessage::ElevatorState { id, floor, direction, call_buttons })
            },
            "COMPLETED" => {
                if parts.len() < 3 {
                    return None;
                }
                
                let floor = parts[1].parse::<u8>().ok()?;
                let direction = parts[2].parse::<u8>().ok()?;
                
                Some(ElevatorMessage::CompletedCall { floor, direction })
            },
            _ => None,
        }
    }
}

================
File: src\elevio\elev.rs
================
#![allow(dead_code)]

use std::fmt; // For implementing Display/Debug traits
use std::io::*; // For read/write traits, etc.
use std::net::TcpStream; // For the TCP connection to the elevator server
use std::sync::*;
// For Arc and Mutex

#[derive(Clone, Debug)]
// Elevator struct defines a mutex lock for the TCP stream and defines total floor count
pub struct Elevator {
    socket: Arc<Mutex<TcpStream>>,
    pub num_floors: u8,
    pub call_buttons: Vec<Vec<u8>>,
    pub current_floor: u8,
    pub current_direction: u8,
}

// Constants for the elevator call buttons
pub const HALL_UP: u8 = 0;
pub const HALL_DOWN: u8 = 1;
pub const CAB: u8 = 2;

// Constants for the elevator direction
pub const DIRN_DOWN: u8 = u8::MAX;
pub const DIRN_STOP: u8 = 0;
pub const DIRN_UP: u8 = 1;


impl Elevator {
    // Initializes a new 'Elevator' by connecting a TCP socket to the server address
    pub fn init(addr: &str, num_floors: u8) -> Result<Elevator> {
        Ok(Self {
            // Arc + Mutex is used to create a thread-safe reference counted pointer
            socket: Arc::new(Mutex::new(TcpStream::connect(addr)?)),
            num_floors,
            call_buttons: vec![],
            current_floor: 0,
            current_direction: DIRN_STOP,
        })
    }

    // Function to set the motor direction
    pub fn motor_direction(&self, dirn: u8) {
        let buf = [1, dirn, 0, 0];
        let mut sock = self.socket.lock().unwrap();
        sock.write(&buf).unwrap();
    }

    // Function to set the call button light
    pub fn call_button_light(&self, floor: u8, call: u8, on: bool) {
        let buf = [2, call, floor, on as u8];
        let mut sock = self.socket.lock().unwrap();
        sock.write(&buf).unwrap();
    }

    // Function to set the floor indicator
    pub fn floor_indicator(&self, floor: u8) {
        let buf = [3, floor, 0, 0];
        let mut sock = self.socket.lock().unwrap();
        sock.write(&buf).unwrap();
    }

    // Function to set the door light
    pub fn door_light(&self, on: bool) {
        let buf = [4, on as u8, 0, 0];
        let mut sock = self.socket.lock().unwrap();
        sock.write(&buf).unwrap();
    }

    // Function to set the stop button light
    pub fn stop_button_light(&self, on: bool) {
        let buf = [5, on as u8, 0, 0];
        let mut sock = self.socket.lock().unwrap();
        sock.write(&buf).unwrap();
    }

    // Function to check if a call button is pressed
    pub fn call_button(&self, floor: u8, call: u8) -> bool {
        let mut buf = [6, call, floor, 0];
        let mut sock = self.socket.lock().unwrap();
        sock.write(&mut buf).unwrap();
        sock.read(&mut buf).unwrap();
        buf[1] != 0
    }

    // Function to check the floor sensor
    pub fn floor_sensor(&self) -> Option<u8> {
        let mut buf = [7, 0, 0, 0];
        let mut sock = self.socket.lock().unwrap();
        sock.write(&buf).unwrap();
        sock.read(&mut buf).unwrap();
        if buf[1] != 0 {
            Some(buf[2])
        } else {
            None
        }
    }

    // Function to check if the stop button is pressed
    pub fn stop_button(&self) -> bool {
        let mut buf = [8, 0, 0, 0];
        let mut sock = self.socket.lock().unwrap();
        sock.write(&buf).unwrap();
        sock.read(&mut buf).unwrap();
        buf[1] != 0
    }

    // Function to check if there is an obstruction
    pub fn obstruction(&self) -> bool {
        let mut buf = [9, 0, 0, 0];
        let mut sock = self.socket.lock().unwrap();
        sock.write(&buf).unwrap();
        sock.read(&mut buf).unwrap();
        buf[1] != 0
    }
}

// Implement Display trait for Elevator struct
impl fmt::Display for Elevator {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let addr = self.socket.lock().unwrap().peer_addr().unwrap();
        write!(f, "Elevator@{}({})", addr, self.num_floors)
    }
}

================
File: src\elevio\fault_handler.rs
================
// Implementation for src/elevio/fault_handler.rs
// This module will handle fault detection and recovery

use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant, SystemTime};
use std::thread;

// Constants for heartbeat timing
const HEARTBEAT_INTERVAL: Duration = Duration::from_millis(500);
const HEARTBEAT_TIMEOUT: Duration = Duration::from_secs(2);
const ELEVATOR_TIMEOUT: Duration = Duration::from_secs(5); // Time to consider an elevator disconnected

// Structure to track elevator health
pub struct ElevatorHealthMonitor {
    last_seen: HashMap<String, Instant>,
    active_elevators: Arc<Mutex<Vec<String>>>,
}

impl ElevatorHealthMonitor {
    pub fn new() -> Arc<Mutex<Self>> {
        Arc::new(Mutex::new(Self {
            last_seen: HashMap::new(),
            active_elevators: Arc::new(Mutex::new(Vec::new())),
        }))
    }

    // Record that we've seen an elevator
    pub fn record_heartbeat(&mut self, elevator_id: &str) {
        self.last_seen.insert(elevator_id.to_string(), Instant::now());
        
        // Ensure this elevator is in our active list
        let mut active = self.active_elevators.lock().unwrap();
        if !active.contains(&elevator_id.to_string()) {
            active.push(elevator_id.to_string());
            println!("Elevator {} is now active", elevator_id);
        }
    }

    // Check if an elevator is still active
    pub fn is_active(&self, elevator_id: &str) -> bool {
        if let Some(last_seen) = self.last_seen.get(elevator_id) {
            last_seen.elapsed() < ELEVATOR_TIMEOUT
        } else {
            false
        }
    }

    // Get all active elevator IDs
    pub fn get_active_elevators(&self) -> Vec<String> {
        self.last_seen
            .iter()
            .filter(|(_, last_seen)| last_seen.elapsed() < ELEVATOR_TIMEOUT)
            .map(|(id, _)| id.clone())
            .collect()
    }

    // Check for and handle disconnected elevators
    pub fn check_disconnected_elevators(&mut self) -> Vec<String> {
        let current_time = Instant::now();
        let mut disconnected = Vec::new();
        
        // Find elevators that haven't been seen recently
        for (id, last_seen) in &self.last_seen {
            if current_time.duration_since(*last_seen) > ELEVATOR_TIMEOUT {
                disconnected.push(id.clone());
            }
        }
        
        // Remove disconnected elevators from our tracking
        for id in &disconnected {
            self.last_seen.remove(id);
            
            // Also remove from active elevators list
            let mut active = self.active_elevators.lock().unwrap();
            if let Some(pos) = active.iter().position(|x| x == id) {
                active.remove(pos);
                println!("Elevator {} disconnected", id);
            }
        }
        
        disconnected
    }
}

// Function to start the health monitoring in a background thread
pub fn start_health_monitoring(
    health_monitor: Arc<Mutex<ElevatorHealthMonitor>>,
    hall_calls: Arc<Mutex<HashMap<(u8, u8), (String, u64)>>>,
) {
    thread::spawn(move || {
        loop {
            // Sleep for a bit before checking
            thread::sleep(HEARTBEAT_INTERVAL);
            
            // Check for disconnected elevators
            let disconnected = {
                let mut monitor = health_monitor.lock().unwrap();
                monitor.check_disconnected_elevators()
            };
            
            // If we found disconnected elevators, reassign their hall calls
            if !disconnected.is_empty() {
                reassign_hall_calls(&disconnected, hall_calls.clone());
            }
        }
    });
}

// Function to reassign hall calls from disconnected elevators
fn reassign_hall_calls(
    disconnected_elevators: &[String],
    hall_calls: Arc<Mutex<HashMap<(u8, u8), (String, u64)>>>,
) {
    let mut calls_to_reassign = Vec::new();
    
    // Find calls assigned to disconnected elevators
    {
        let hall_calls_guard = hall_calls.lock().unwrap();
        for ((floor, direction), (assigned_to, timestamp)) in hall_calls_guard.iter() {
            if disconnected_elevators.contains(assigned_to) {
                calls_to_reassign.push((*floor, *direction, *timestamp));
            }
        }
    }
    
    // Reassign each call
    for (floor, direction, timestamp) in calls_to_reassign {
        println!("Reassigning hall call: floor {}, direction {}", floor, direction);
        
        // Mark the call as unassigned so it will be picked up by active elevators
        let mut hall_calls_guard = hall_calls.lock().unwrap();
        hall_calls_guard.insert((floor, direction), (String::new(), timestamp));
    }
}

// Utility function to get current timestamp in seconds
pub fn current_timestamp() -> u64 {
    match SystemTime::now().duration_since(SystemTime::UNIX_EPOCH) {
        Ok(n) => n.as_secs(),
        Err(_) => 0,
    }
}

// Function to persist elevator state to disk (for recovery after restart)
pub fn persist_elevator_state(
    elevator_id: &str, 
    current_floor: u8,
    current_direction: u8,
    call_buttons: &Vec<Vec<u8>>,
) -> std::io::Result<()> {
    use std::fs::File;
    use std::io::Write;
    
    // Create a simple state file
    let filename = format!("elevator_{}_state.txt", elevator_id);
    let mut file = File::create(filename)?;
    
    // Write current floor and direction
    writeln!(file, "{}", current_floor)?;
    writeln!(file, "{}", current_direction)?;
    
    // Write call buttons
    for call in call_buttons {
        if call.len() >= 2 {
            writeln!(file, "{},{}", call[0], call[1])?;
        }
    }
    
    Ok(())
}

// Function to load elevator state from disk (for recovery after restart)
pub fn load_elevator_state(elevator_id: &str) -> Option<(u8, u8, Vec<Vec<u8>>)> {
    use std::fs::File;
    use std::io::{BufRead, BufReader};
    
    let filename = format!("elevator_{}_state.txt", elevator_id);
    match File::open(filename) {
        Ok(file) => {
            let reader = BufReader::new(file);
            let lines: Vec<String> = reader.lines().filter_map(Result::ok).collect();
            
            if lines.len() >= 2 {
                let current_floor = lines[0].parse::<u8>().unwrap_or(0);
                let current_direction = lines[1].parse::<u8>().unwrap_or(0);
                
                let mut call_buttons = Vec::new();
                for i in 2..lines.len() {
                    let parts: Vec<&str> = lines[i].split(',').collect();
                    if parts.len() >= 2 {
                        if let (Ok(floor), Ok(direction)) = (parts[0].parse::<u8>(), parts[1].parse::<u8>()) {
                            call_buttons.push(vec![floor, direction]);
                        }
                    }
                }
                
                return Some((current_floor, current_direction, call_buttons));
            }
            None
        },
        Err(_) => None
    }
}

================
File: src\elevio\poll.rs
================
use crossbeam_channel as cbc;
use std::thread;
use std::time;

use super::elev;

#[derive(Debug)]
// Struct to create a call button event: six callbuttons and four floorbuttons
pub struct CallButton {
    pub floor: u8, // u8 = 8-bit unsigned integer 
    pub call: u8, // u8 = 8-bit unsigned integer
}

// A function that polls for call button presses.
// If a button is pressed, send an event
pub fn call_buttons(elev: elev::Elevator, ch: cbc::Sender<CallButton>, period: time::Duration) {
    let mut prev = vec![[false; 3]; elev.num_floors.into()];
    loop {
        for f in 0..elev.num_floors {
            for c in 0..3 {
                let v = elev.call_button(f, c);
                if v && prev[f as usize][c as usize] != v {
                    ch.send(CallButton { floor: f, call: c }).unwrap();
                }
                prev[f as usize][c as usize] = v;
            }
        }
        thread::sleep(period)
    }
}

pub fn floor_sensor(elev: elev::Elevator, ch: cbc::Sender<u8>, period: time::Duration) {
    let mut prev = u8::MAX;
    loop {
        if let Some(f) = elev.floor_sensor() {
            if f != prev {
                ch.send(f).unwrap();
                prev = f;
            }
        }
        thread::sleep(period)
    }
}

pub fn stop_button(elev: elev::Elevator, ch: cbc::Sender<bool>, period: time::Duration) {
    let mut prev = false;
    loop {
        let v = elev.stop_button();
        if prev != v {
            ch.send(v).unwrap();
            prev = v;
        }
        thread::sleep(period)
    }
}

pub fn obstruction(elev: elev::Elevator, ch: cbc::Sender<bool>, period: time::Duration) {
    let mut prev = false;
    loop {
        let v = elev.obstruction();
        if prev != v {
            ch.send(v).unwrap();
            prev = v;
        }
        thread::sleep(period)
    }
}

================
File: src\network\p2p_connect.rs
================
use std::collections::HashMap;
use std::io::{Read, Write};
use std::net::{TcpListener, TcpStream};
use std::sync::{Arc, Mutex};
use std::thread;

/// PeerManager: több kapcsolatot kezel egyszerre
/// PeerManager: manages multiple connections simultaneously
pub struct NetworkManager {
    peers: Arc<Mutex<HashMap<String, TcpStream>>>,
}

impl NetworkManager {
    /// Új `PeerManager` létrehozása
    /// Creating a new `PeerManager`
    pub fn new() -> Arc<Self> {
        Arc::new(NetworkManager {
            peers: Arc::new(Mutex::new(HashMap::new())),
        })
    }

    /// Új peer hozzáadása
    /// Adding a new peer
    pub fn add_peer(&self, addr: String, stream: TcpStream) {
        self.peers.lock().unwrap().insert(addr, stream);
    }

    /// Üzenet küldése egy adott peernek
    /// Sending a message to a specific peer
    /*
    pub fn send_message(&self, addr: &str, message: &str) {
        if let Some(stream) = self.peers.lock().unwrap().get_mut(addr) {
            stream.write_all(message.as_bytes()).unwrap();
        } 
        /*
        else {
            println!("Peer {} not found!", addr);
        } */
    }

    /// Send a message to all connected peers
    pub fn broadcast_message(&self, message: &str) {
        let peers = self.peers.lock().unwrap();
        
        for (addr, stream) in peers.iter() {
            match stream.try_clone() {
                Ok(mut stream) => {
                    if let Err(e) = stream.write_all(message.as_bytes()) {
                        println!("Failed to send to {}: {}", addr, e);
                    }
                },
                Err(e) => println!("Failed to clone stream for {}: {}", addr, e),
            }
        }
    }
    */

    pub fn send_message(&self, addr: &str, message: &str) {
        let mut peers = self.peers.lock().unwrap_or_else(|e| e.into_inner());
        if let Some(stream) = peers.get_mut(addr) {
            if let Err(e) = stream.write_all(message.as_bytes()) {
                println!("Failed to send message to {}: {}. Removing peer.", addr, e);
                peers.remove(addr);
            }
        }
    }
    
    pub fn broadcast_message(&self, message: &str) {
        let mut peers = self.peers.lock().unwrap_or_else(|e| e.into_inner());
        let mut to_remove = Vec::new();
        for (addr, stream) in peers.iter_mut() {
            if let Err(e) = stream.write_all(message.as_bytes()) {
                println!("Failed to broadcast to {}: {}. Marking for removal.", addr, e);
                to_remove.push(addr.clone());
            }
        }
        for addr in to_remove {
            peers.remove(&addr);
        }
    }
    
    

    /// Bejövő kapcsolatokat kezelő függvény
    /// Function handling incoming connections
    fn handle_client(mut stream: TcpStream, peers: Arc<Mutex<HashMap<String, TcpStream>>>) {
        let mut buffer = [0; 512];
        let addr = stream.peer_addr().unwrap().to_string();

        loop {
            match stream.read(&mut buffer) {
                Ok(0) => {
                    println!("Peer disconnected: {}", addr);
                    peers.lock().unwrap().remove(&addr);
                    break;
                }
                Ok(n) => {
                    let message = String::from_utf8_lossy(&buffer[..n]);
                    println!("[{}] Received: {}", addr, message);
                }
                Err(_) => break,
            }
        }
    }

    /// Peerhez való csatlakozás
    /// Connecting to a peer
    pub fn connect_to_peer(peer_manager: Arc<Self>, addr: &str) {
        match TcpStream::connect(addr) {
            Ok(stream) => {
                println!("Connected to peer: {}", addr);
                peer_manager.add_peer(addr.to_string(), stream.try_clone().unwrap());

                let peers_clone = Arc::clone(&peer_manager.peers);
                let stream_clone = stream.try_clone().unwrap();
                // let addr_clone = addr.to_string();

                thread::spawn(move || {
                    NetworkManager::handle_client(stream_clone, peers_clone);
                });
            }
            Err(e) => println!("Failed to connect to {}: {}", addr, e),
        }
    }

    /// Szerver elindítása bejövő kapcsolatokhoz
    /// Starting the server for incoming connections
    pub fn start_listener(peer_manager: Arc<Self>, port: u16) {
        let listener = TcpListener::bind(("0.0.0.0", port)).expect("Could not bind to address");
        let peers_clone = Arc::clone(&peer_manager.peers);

        thread::spawn(move || {
            for stream in listener.incoming() {
                match stream {
                    Ok(stream) => {
                        let addr = stream.peer_addr().unwrap().to_string();
                        println!("New peer connected: {}", addr);

                        peer_manager.add_peer(addr.clone(), stream.try_clone().unwrap());
                        let peers_inner = Arc::clone(&peers_clone);

                        thread::spawn(move || {
                            NetworkManager::handle_client(stream, peers_inner);
                        });
                    }
                    Err(e) => eprintln!("Connection failed: {}", e),
                }
            }
        });
    }
}

// **Függvények a PeerManager kezelésére**
// **Functions for handling PeerManager**
pub fn start_peer_manager(listening_port: u16) -> Arc<NetworkManager> {
    let peer_manager = NetworkManager::new();
    NetworkManager::start_listener(Arc::clone(&peer_manager), listening_port);
    peer_manager
}

pub fn connect(peer_manager: Arc<NetworkManager>, addr: &str) {
    NetworkManager::connect_to_peer(peer_manager, addr);
}

pub fn send(peer_manager: Arc<NetworkManager>, addr: &str, message: &str) {
    peer_manager.send_message(addr, message);
}
